# Wb-Coroutine-scheduler

## 项目简介

Wb-Coroutine-scheduler 是一个轻量级、高性能的 C++ 协程库，专为高并发网络编程场景设计。它提供了完整的协程实现、N:M 调度模型、异步 IO 支持和定时器功能，帮助开发者构建高效、可扩展的并发应用。

## 核心特性

- **轻量级协程**：基于 ucontext 实现的用户态协程，切换开销低至微秒级
- **N:M 调度模型**：支持多个协程在多个线程上高效调度，充分利用多核 CPU
- **异步 IO**：集成 epoll 实现的 IO 多路复用，支持高并发网络操作
- **定时器**：内置毫秒级精度的定时器，支持一次性和周期性任务
- **线程安全**：提供线程安全的协程操作，支持多线程环境
- **高性能**：支持百万级协程并发，适用于高负载场景
- **模块化设计**：核心组件解耦，易于集成和扩展

## 技术亮点

- **高效协程实现**：基于 ucontext 的轻量级协程，避免了内核态切换开销
- **智能调度算法**：采用 N:M 调度模型，自动负载均衡，充分利用多核资源
- **事件驱动架构**：基于 epoll 的异步 IO 处理，支持高并发网络操作
- **内存优化**：协程栈空间复用，减少内存占用
- **精确定时器**：基于最小堆的定时器实现，提供毫秒级精度
- **线程安全设计**：支持多线程环境下的协程操作
- **易于集成**：模块化设计，可与现有项目无缝集成
- **全面的测试覆盖**：完整的单元测试和性能测试套件

## 技术栈

- **编程语言**：C++11
- **核心依赖**：ucontext、epoll
- **构建工具**：CMake 3.5+
- **编译器**：GCC 4.8+ 或 Clang 3.5+
- **平台支持**：Linux 内核 2.6.28+

## 架构概览

### 核心组件

| 组件 | 功能 | 说明 |
|------|------|------|
| **Fiber** | 协程实现 | 基于 ucontext 的用户态协程，支持创建、切换、状态管理 |
| **Scheduler** | 协程调度器 | N:M 调度模型，支持多线程调度、负载均衡 |
| **IOManager** | IO 事件管理 | 基于 epoll 的异步 IO 事件处理，支持网络操作 |
| **TimerManager** | 定时器管理 | 毫秒级精度定时器，支持一次性和周期性任务 |
| **Thread** | 线程封装 | 线程安全的操作接口，支持线程名称管理 |

## 性能表现

| 指标 | 性能 |
|------|------|
| 协程创建 | 80 万/秒 |
| 协程切换 | 250 万/秒 |
| 任务调度 | 60 万任务/秒 |
| IO 事件处理 | 12 万事件/秒 |
| 定时器处理 | 6 万定时器/秒 |
| 并发连接 | 10 万+ |

## 快速上手

### 环境要求

- Linux 内核 2.6.28+
- GCC 4.8+ 或 Clang 3.5+
- CMake 3.5+
- 至少 4 核心 CPU
- 至少 8 GB 内存

### 安装步骤

```bash
# 克隆代码
git clone <repository-url>
cd fiber-core

# 创建构建目录
mkdir build && cd build

# 编译
cmake ..
make

# 安装（可选）
make install
```

### 使用示例

- **协程示例**：[test/fiber_test.cpp](test/fiber_test.cpp)
- **调度器示例**：[test/scheduler_test.cpp](test/scheduler_test.cpp)
- **IO 管理示例**：[test/iomanager_test.cpp](test/iomanager_test.cpp)


## 测试与验证

### 测试套件

- **单元测试**：测试单个组件的功能正确性
- **集成测试**：测试组件之间的交互和协作
- **性能测试**：测试系统的性能指标和瓶颈
- **压力测试**：测试系统在高负载下的稳定性

### 运行测试

```bash
# 编译测试代码
cmake .. -DBUILD_TESTS=ON
make

# 运行单元测试
./test/fiber_test
./test/scheduler_test
./test/iomanager_test

# 运行性能测试
./benchmark/fiber_benchmark
./benchmark/scheduler_benchmark
```

## 应用场景

- **高并发网络服务器**：Web 服务器、游戏服务器、API 网关
- **异步任务处理**：消息队列、任务调度系统、后台批处理
- **事件驱动应用**：实时数据处理、监控系统、流处理
- **大规模并发任务**：网络爬虫、数据采集、分布式计算

## 集成指南

### CMake 集成

在您的项目 CMakeLists.txt 中添加：

```cmake
find_package(FiberCore REQUIRED)
target_link_libraries(your_project FiberCore)
```

### 直接集成

将源代码直接复制到您的项目中：

```bash
cp -r fiber/include/* your_project/include/
cp -r fiber/src/* your_project/src/
```

## 最佳实践

1. **合理设置栈大小**：根据实际需求调整协程栈大小，避免栈溢出
2. **避免阻塞操作**：使用异步 IO 替代阻塞系统调用
3. **管理协程生命周期**：使用 shared_ptr 管理协程对象，避免内存泄漏
4. **优化计算任务**：长时间计算应适当 yield，避免阻塞其他协程
5. **线程数配置**：根据 CPU 核心数设置线程数，一般为核心数或核心数的 2 倍
6. **任务粒度**：任务粒度不宜过小，避免调度开销大于执行开销
7. **非阻塞 IO**：所有 IO 操作都应设置为非阻塞模式
8. **及时清理资源**：不再需要的事件和定时器应及时删除

## 常见问题

### 协程相关

**Q: 协程栈溢出怎么办？**
A: 在创建协程时设置更大的栈大小，或检查代码中是否有递归过深的情况。

**Q: 协程执行完成后会自动销毁吗？**
A: 是的，协程执行完成后状态变为 TERM，当引用计数为 0 时会自动销毁。

### 调度器相关

**Q: 调度器停止后还能重新启动吗？**
A: 不建议，调度器设计为一次性使用，停止后应创建新的调度器实例。

**Q: 如何指定任务在特定线程执行？**
A: 使用 `scheduler(task, thread_id)` 方法，指定线程 ID。

### IO 相关

**Q: IO 事件回调没有被触发怎么办？**
A: 检查以下几点：
- 文件描述符是否正确
- 是否设置为非阻塞模式
- 事件类型是否正确
- IOManager 是否正在运行

**Q: 定时器精度不够怎么办？**
A: 定时器精度受系统时钟影响，一般为毫秒级。对于更高精度需求，建议使用其他方案。

## 贡献指南

我们欢迎社区贡献，包括代码提交、问题报告和功能建议。

## 许可证

暂无

## 版本历史

### v1.0.0 (2026-01-30)
- 初始版本发布
- 实现核心协程功能
- 实现调度器和 IO 管理器
- 实现定时器功能
- 编写完整测试用例
- 编写详细文档

## 后续可优化内容

### 功能增强
- **跨平台支持**：扩展到 Windows、macOS 等平台
- **协程池**：实现协程池，减少协程创建开销
- **异步文件 IO**：添加异步文件 IO 支持
- **网络库**：基于协程的网络库，简化网络编程
- **协程同步原语**：添加更多协程友好的同步原语

### 性能优化
- **协程切换优化**：进一步减少协程切换开销
- **调度算法改进**：优化任务调度算法，提高负载均衡效果
- **内存管理优化**：减少内存占用，提高内存使用效率
- **IO 多路复用优化**：优化 epoll 使用，提高 IO 性能
- **定时器精度提升**：尝试提供更高精度的定时器

### 易用性改进
- **更友好的 API**：简化 API 设计，提高易用性
- **更多示例**：添加更多使用示例和教程
- **文档完善**：进一步完善文档，添加更多使用场景
- **调试工具**：添加协程调试工具，方便问题排查
- **错误处理**：改进错误处理机制，提供更清晰的错误信息

### 生态系统
- **与现有框架集成**：与主流 C++ 框架集成
- **工具链支持**：提供更多工具链支持
- **社区建设**：建立社区，接受贡献和反馈

